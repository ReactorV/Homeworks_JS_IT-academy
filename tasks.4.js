//TASK 1-----------------------------------
Задание 1:
    Написать функцию pow(x,n), которая возвращает x в степени n,
    иначе говоря, умножает x на себя n раз и возвращает результат.
    Создать страницу, которая запрашивает x и n, а затем выводит результат pow(x,n).
    В этой задаче функция обязана поддерживать только натуральные значения n, т.е. целые от 1 и выше.

//SOLUTION---------------------------------
function pow(x, n) {
  var result = x;

  for (var i = 1; i < n; i++) {
    result *= x;
  }

    return result;
}

var valueX = prompt('Введите значение х');
var valueN = prompt('Введите значение степени N');

if (valueX > 1 && valueN > 1) {
  alert( pow(valueX,valueN) );
} else {
  alert('Введите целые числа от 1 и выше')
}


//TASK 3-----------------------------------
Задание 3 *:
 Написать функцию sumTo(n), которая для данного n вычисляет сумму чисел от 1 до n, например:
  sumTo(1) = 1
  sumTo(2) = 2 + 1 = 3
  sumTo(3) = 3 + 2 + 1 = 6
  sumTo(4) = 4 + 3 + 2 + 1 = 10
  sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050

  Сделать три варианта решения:
  - с использованием цикла
  - через рекурсию, sumTo(n) = n + sumTo(n-1) для n > 1
  - с использованием формулы для суммы арифметической прогрессии

Ответить на вопросы в комментариях:
  Какой вариант решения самый быстрый? Самый медленный? Почему?
  Можно ли при помощи рекурсии посчитать sumTo(100000)? Если нет, то почему?

//SOLUTION---------------------------------
function sumTo(n) {        // данный способ более предпочтителен рекурсии так как не требует затрат памяти 
  var sum = 0;            // на дополнительные вложенные вызовы
                             
  for (var i = 0; i <= n; i++) {
    sum += i;
  }

  return sum;
}

function sumTo(n) {         //самый быстрый способ решения, потребуется меньше всего памяти т.к. вычисление по одной формуле: 3 операции
  return n * (n + 1) / 2;
}

function sumTo(n) {  //самый медленный способ решения, потребуется больше всего памяти для вложенных вызовов в стеке контекстов
  if (n == 1) {
    return 1;
  } 
  return n + sumTo(n-1);
}

Можно ли при помощи рекурсии посчитать sumTo(100000)? Если нет, то почему? - //нет, так количество вложенных вызовов в рекурсии
                                                                              //ограничено (около 10 000) 

//TASK 2-----------------------------------
Задание 2.
Разработать чистую функцию treeSum, которая получает массив, элементы которого могут быть числами или снова массивами
, и так до любого уровня. Функция должна рассчитать и вернуть сумму всех числовых элементов массива со всех уровней.
При описании функции не описывать каких-либо вложенных в нее функций.
Проверить работу функции можно на следующем массиве (сумма 50):

var arr = [ 5, 7,
  [4, [2], 8, [1,3], 2 ],
  [9, [] ],
  1, 8
] 

//SOLUTION---------------------------------
var arr = [ 5, 7,
            [4, [2], 8, [1,3], 2 ],
            [9, [] ],
            1, 8
          ]; 

function treeSum(array, length) {
  var res = [];
  var sum = 0;
  
  for (var i = 0; i < array.length; i++) {
    if (!array[i].length) {
      res.push( + array[i]);
    } else {
      for(var z = 0; z < treeSum(array[i], null).length; z ++) {
        res.push(treeSum(array[i], null)[z]);
      }
    }
  }

  if(length) {
    for (i = 0; i < res.length; i++){
      sum += res[i];
    }
    return sum;
  }
  return res;
}
var x = treeSum(arr, arr.length);